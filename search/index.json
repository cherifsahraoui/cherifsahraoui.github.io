[{"content":"Testing in production has long been seen as risky, often causing debates among developers, testers, and stakeholders. But in today\u0026rsquo;s fast-paced tech world, it\u0026rsquo;s becoming more common. Testing in production does not mean skipping tests in lower environments and solely relying on production testing. It simply means that after thorough testing in staging and other pre-production environments, we continue to validate in production to ensure real-world reliability and performance.\nUnderstanding Testing in Production Production testing means running tests in a live environment. While staging and development environments try to mimic production, they often fall short. Testing in production helps bridge this gap, ensuring that applications work as expected under real conditions.\nWhen Production Testing is Crucial Sometimes, testing in lower environments is not enough. For example:\nThird-Party Dependencies: Some services, like external APIs, behave differently in production than in staging. Real User Load: Performance and scalability issues only become clear when real users interact with the system. Complex Microservices: Staging environments often lack the full set of dependencies that exist in production. If the QA team skips even basic manual smoke tests in production, there\u0026rsquo;s a risk of blindly promoting changes that could lead to critical failures. Production validation acts as a final safeguard, helping to catch unforeseen issues that might not surface in lower environments due to differences in data, traffic patterns, or infrastructure nuances. Risks of Performing Tests in Production and Mitigation Strategies Risk Description Mitigation Strategy Unintended User Impact Test actions might trigger unintended user-visible changes, such as notifications, emails, or altered UI states. Use test accounts and feature flags, exclude real users from test scenarios, and monitor user-facing effects. Data Corruption Test executions could modify or delete real production data, impacting reporting and business operations. Implement strict data isolation, use synthetic or readonly test data, and ensure proper rollback mechanisms. Performance Degradation Automated or manual tests might introduce additional load, slowing down the system for real users. Schedule tests during low-traffic periods, monitor system load, and set rate limits on test executions. Security Risks Test data or scripts might unintentionally expose sensitive information or trigger security vulnerabilities. Follow security best practices, sanitize test data, and use proper authentication and access controls for testing. False Positives/Negatives Differences between test and real user behavior might lead to misleading test results, causing unnecessary rollbacks or missed issues. Use A/B testing, shadow testing, and compare test results with historical production data. Benefits of Testing in Production Despite its risks, production testing has major benefits:\nReal-World Validation: Captures real interactions that can\u0026rsquo;t be replicated in lower environments. Early Bug Detection: Finds hidden issues before they impact all users. Better Performance Insights: Ensures scalability by testing under real traffic conditions. Data-Driven Decisions: Enables A/B testing and feature comparison. Real World Examples where Testing in Production was Essential Testing in production environments can uncover issues that might not surface during pre-production testing. Here are two real-world scenarios illustrating this: 1. Mobile App Crashes Due to Network Variability A political campaign\u0026rsquo;s mobile app, \u0026ldquo;Campaign Sidekick,\u0026rdquo; experienced significant issues during field operations. The app, designed to track canvassers, relied on high-speed internet connectivity. In rural areas with slow or unreliable internet, the app struggled to function properly, leading to data upload failures and task reassignment glitches. This resulted in wasted efforts and incomplete voter contact. The issues were exacerbated by the app\u0026rsquo;s inability to operate effectively offline, highlighting the importance of testing under diverse real-world conditions. source 2. Windows Blue Screen of Death (BSOD) from Faulty Update In August 2014, Microsoft released a security update (MS14-045) intended to address vulnerabilities in the Windows kernel. However, the update inadvertently caused some systems to crash, displaying the \u0026ldquo;Blue Screen of Death\u0026rdquo; (BSOD). This issue was traced back to a faulty patch that had not been adequately tested in production environments. The incident underscores the critical need for thorough testing of updates in production to prevent system instability and data loss. source These examples highlight the importance of testing in production to identify issues that may not be evident in controlled testing environments. Implementing robust testing protocols and monitoring systems can help mitigate such risks.\nConclusion Testing in production is no longer a reckless practice, itâ€™s a necessity in modern software development. When done right, it helps catch real-world issues early, improves software quality, and enhances user experience. However, it requires the right tools, best practices, and a well-prepared team. By combining automation, monitoring, and feature flags, companies can safely test in production and deliver high-quality software with confidence.\n","date":"2025-02-13T10:39:00+02:00","image":"cherifsahraoui.github.io/cherifsahraoui.github.io/cherifsahraoui.github.io/p/testing-in-production-risks-benefits-and-best-practices/prod_testing_img_hu_9585bc95a7621926.png","permalink":"cherifsahraoui.github.io/p/testing-in-production-risks-benefits-and-best-practices/","title":"Testing in Production: Risks, Benefits, and Best Practices"},{"content":"In this tutorial, we\u0026rsquo;ll guide you through creating a simple, solution to route all traffic through your home network using two Raspberry Pi devices and ZeroTier. This setup allows you to securely connect to your home network from anywhere and route all your internet traffic through your home network, providing an extra layer of security and privacy. You will also get the same IP address as you Home network from anywhere in the world. ZeroTier is a powerful tool that allows you to create secure virtual networks, enabling your devices to communicate as if they\u0026rsquo;re on the same local network, regardless of their physical locations.\nNote: This tutorial is inspired by the DigitalOcean guide and harivemula guide.\nPrerequisites Before we begin, ensure you have the following:\nTwo Raspberry Pi devices with Raspberry Pi OS installed and updated. (I used two Raspberry Pi 3 devices with Raspberry Pi OS (64-bit, Kernel version: 6.6) for this tutorial.) Internet connectivity for both Raspberry Pi devices. A ZeroTier account. If you don\u0026rsquo;t have one, you can create it for free at ZeroTier Central. Overview of the Architecture Step 1: Set Up a ZeroTier Network Create a ZeroTier Account Visit ZeroTier Central and sign up for a free account. Create a New Network Once logged in, click on \u0026ldquo;Create A Network.\u0026rdquo; A new network will be created, and you\u0026rsquo;ll be provided with a unique Network ID. Note this ID, as you\u0026rsquo;ll need it later. Configure the Network Click on your newly created network to access its settings. Here, you can set a name for your network and adjust other settings as needed. Ensure that \u0026ldquo;Private\u0026rdquo; is selected under \u0026ldquo;Access Control\u0026rdquo; to keep your network secure. Step 2: Install ZeroTier on the Raspberry Pi Devices Perform the following steps on both Raspberry Pi devices.\nInstall needed packages Install the ZeroTier repository and its GPG key:\n1 curl https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg | gpg --dearmor | sudo tee /usr/share/keyrings/zerotierone-archive-keyring.gpg \u0026gt;/dev/null 1 RELEASE=$(lsb_release -cs) 1 echo \u0026#34;deb [signed-by=/usr/share/keyrings/zerotierone-archive-keyring.gpg] http://download.zerotier.com/debian/$RELEASE $RELEASE main\u0026#34; | sudo tee /etc/apt/sources.list.d/zerotier.list 1 2 sudo apt update sudo apt install -y zerotier-one Verify the Installation:\n1 sudo zerotier-cli status You should see an output indicating that ZeroTier is online.\nInstall additional packages:\n1 sudo apt install dnsmasq hostapd iptables dhcpcd5 dnsmasq: A lightweight DNS and DHCP server. iptables: A tool for configuring the Linux kernel firewall. hostapd: A user space daemon for access point and authentication servers. (Only needed for the Travel Raspberry Pi for setting up a Wi-Fi access point) dhcpcd5: A DHCP (Dynamic Host Configuration Protocol Client Daemon) client and server. (Only needed for the Travel Raspberry Pi for setting up a static IP address)\nStep 3: Join your ZeroTier Network Run the following command on each Raspberry Pi:\n1 sudo zerotier-cli join [Your_Network_ID] Replace [Your_Network_ID] with the Network ID you noted earlier.\nAuthorize the Devices:\nIn ZeroTier Central, under your network\u0026rsquo;s settings, scroll down to the \u0026ldquo;Members\u0026rdquo; section.\nYou should see the Raspberry Pi devices listed as new devices. Check the \u0026ldquo;Auth?\u0026rdquo; box next to each device to authorize them on the network and click \u0026ldquo;Authorize\u0026rdquo; button.\nYou can also rename the devices to make them easily identifiable.\nVerify Connectivity:\nOn each Raspberry Pi, list the networks to confirm they\u0026rsquo;re connected:\n1 sudo zerotier-cli listnetworks You should see your network listed with the status \u0026ldquo;OK.\u0026rdquo;\nStep 4: Test the VPN Connection Obtain the ZeroTier IP Addresses: In ZeroTier Central, under the \u0026ldquo;Members\u0026rdquo; section, note the managed IP addresses assigned to each Raspberry Pi. If no IP address is assigned automatically, you can assign one manually. In this tutorial, we\u0026rsquo;ll use the ZeroTier IP addresses 192.168.191.99 for the Travel Raspberry Pi and 192.168.191.134 for the Home Raspberry Pi.\nTest Connectivity: You can join the same network on your local machine using the ZeroTier client and ping the Raspberry Pi devices to verify connectivity.\n1 ping [ZeroTier_IP_of_Raspberry_Pi] You should receive responses, indicating a successful VPN connection.\nStep 5: Configure Home Raspberry Pi To configure the home Raspberry Pi to route all traffic through it, follow these steps:\nEnable IP Forwarding:\nOpen the sysctl configuration file:\n1 sudo nano /etc/sysctl.conf Uncomment or add the following line to enable IP forwarding:\n1 2 net.ipv4.ip_forward=1 net.ipv4.conf.all.rp_filter=2 Apply the changes:\n1 sudo sysctl -p Configure dnsmasq:\nOpen the dnsmasq configuration file:\n1 sudo nano /etc/dnsmasq.conf Add the following line to configure the DNS server:\n1 server=192.168.1.1 Configure rc.local:\nOpen the rc.local file:\n1 sudo nano /etc/rc.local Add the following lines before the exit 0 line to join the ZeroTier network and set up NAT:\n1 2 3 4 sudo zerotier-cli join [Your_Network_ID] sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i ztc3qulcfx -o eth0 -j ACCEPT PS: The Home Raspberry Pi may also be connected to the internet via Wi-Fi. In this case, replace eth0 with the interface name of the internet connection (e.g. wlan0).\nMake rc.local file executable:\n1 sudo chmod +x /etc/rc.local Configure ZeroTier Network Settings:\nOpen the ZeroTier network configuration file:\n1 sudo nano /var/lib/zerotier-one/networks.d/[Your_Network_ID].local.conf Add the following lines to allow managed routes and global traffic:\n1 2 3 4 allowManaged=1 allowGlobal=1 allowDefault=1 allowDNS=0 Reboot the Raspberry Pi:\nReboot the Raspberry Pi to apply all changes:\n1 sudo reboot Step 6: Configure Travel Raspberry Pi This Raspberry Pi should be connected to the internet via Ethernet and will act as a Wi-Fi access point for other devices. All traffic from the Wi-Fi clients will be routed through the ZeroTier network and the Home Raspberry Pi. PS: If you want to connect the Travel Raspberry Pi to the internet via Wi-Fi, you need an additional USB Wi-Fi adapter. (not covered in this tutorial) To configure the Travel Raspberry Pi, follow these steps:\nConfigure Static IP Address:\nOpen the DHCP client configuration file:\n1 sudo nano /etc/dhcpcd.conf Add the following lines to set a static IP address for the wlan0 interface:\n1 2 3 interface wlan0 static ip_address=192.168.1.1/24 nohook wpa_supplicant Configure dnsmasq:\nOpen the dnsmasq configuration file:\n1 sudo nano /etc/dnsmasq.conf Add the following lines to configure DHCP and DNS settings:\n1 2 3 4 interface=wlan0 server=8.8.8.8 server=8.8.4.4 dhcp-range=192.168.1.2,192.168.1.200,255.255.255.0,24h Enable wlan0:\nEnsure wlan0 is unblocked:\n1 2 sudo rfkill unblock wlan sudo ifconfig wlan0 up Configure hostapd:\nOpen the hostapd configuration file:\n1 sudo nano /etc/hostapd/hostapd.conf Add the following lines to configure the Wi-Fi access point:\n1 2 3 4 5 6 7 8 9 10 country_code=DE interface=wlan0 ssid=TESTWLAN channel=13 auth_algs=1 wpa=2 wpa_passphrase=[passphrase] wpa_key_mgmt=WPA-PSK wpa_pairwise=TKIP CCMP rsn_pairwise=CCMP Change [passphrase] with your own password for the Wi-Fi access point. The Wi-Fi access point name used here is \u0026ldquo;TESTWLAN\u0026rdquo;\nSet the correct permissions for the configuration file:\n1 sudo chmod 600 /etc/hostapd/hostapd.conf Unmask, start and enable hostapd:\n1 2 3 sudo systemctl unmask hostapd sudo systemctl start hostapd sudo systemctl enable hostapd Configure hostapd to run as a background service:\n1 sudo nano /etc/default/hostapd Add following lines:\n1 2 RUN_DAEMON=yes DAEMON_CONF=\u0026#34;/etc/hostapd/hostapd.conf\u0026#34; Enable IP Forwarding:\nOpen the sysctl configuration file:\n1 sudo nano /etc/sysctl.conf Uncomment or add the following line to enable IP forwarding:\n1 net.ipv4.ip_forward=1 Apply the changes:\n1 sudo sysctl -p Test that the Wi-Fi access point can be enabled:\nRun following command 1 sudo hostapd /etc/hostapd/hostapd.conf Configure rc.local:\nOpen the rc.local file:\n1 sudo nano /etc/rc.local Add the following lines before the exit 0 line to join the ZeroTier network and start necessary services on boot:\n1 2 3 4 5 6 sudo rfkill unblock wlan sudo ifconfig wlan0 up sudo zerotier-cli join [Your_Network_ID] sudo systemctl start dhcpcd sudo iptables -t nat -A POSTROUTING -o ztc3qulcfx -j MASQUERADE sudo hostapd /etc/hostapd/hostapd.conf PS: Replace ztc3qulcfx with the interface name of the ZeroTier network.\nMake rc.local file executable:\n1 sudo chmod +x /etc/rc.local Configure ZeroTier Network Settings:\nOpen the ZeroTier network configuration file:\n1 sudo nano /var/lib/zerotier-one/networks.d/[Your_Network_ID].local.conf Add the following lines to allow managed routes and global traffic:\n1 2 3 4 allowManaged=1 allowGlobal=1 allowDefault=1 allowDNS=0 Reboot the Raspberry Pi:\nReboot the Raspberry Pi to apply all changes:\n1 sudo reboot Step 7: Configure ZeroTier Managed Routes You should now configure the ZeroTier managed routes to ensure that traffic is routed correctly between the Raspberry Pi devices. Following is my ZeroTier managed routes configuration:\nThe IP address 192.168.191.134 is the ZeroTier IP address of the Travel Raspberry PI. 192.168.191.0/24 (LAN) is the ZeroTier serverâ€™s network. Step 8: Test the VPN connection To test the VPN connection, connect to the Wi-Fi access point of the Travel Raspberry Pi and try to access the internet. You should see that all traffic is routed through the Home Raspberry Pi. You can verify this by checking your public IP address, which should match the public IP address of the Home Raspberry Pi.\nAdditional Considerations Security: Ensure that you have strong passwords and firewall rules in place to secure your network.\nPerformance: The performance of your VPN may vary based on the Raspberry Pi model and network conditions.\nTroubleshooting: If you encounter issues, check the logs on both Raspberry Pi devices for error messages and investigate accordingly.\nDesabling the VPN: If you want to disable the VPN, you can simply stop the ZeroTier service on both Raspberry Pi devices:\n1 sudo systemctl stop zerotier-one You can also set allowDefault back to 0:\n1 sudo zerotier-cli set NetworkID allowDefault=0 ","date":"2025-02-09T14:00:00+02:00","image":"cherifsahraoui.github.io/cherifsahraoui.github.io/cherifsahraoui.github.io/p/routing-all-traffic-through-home-with-zerotier-and-two-raspberry-pi-devices/zerotier_hu_dc6f58b4bc679fcf.png","permalink":"cherifsahraoui.github.io/p/routing-all-traffic-through-home-with-zerotier-and-two-raspberry-pi-devices/","title":"Routing All Traffic Through Home with ZeroTier and Two Raspberry Pi Devices"},{"content":"What is Testkube? Testkube is a Test Orchestration and Execution Framework for cloud-native applications. It provides a unified platform for running tests, integrating seamlessly with Kubernetes and existing CI/CD pipelines. Testkube consists of two main components:\nControl Plane: Manages test execution, reporting, and orchestration. It can run in the cloud or on-premises. Agents: Execute tests in your infrastructure and are 100% open source. They can also operate standalone without the Control Plane. Licensing:\nTestkube is available under two licenses: MIT License: Open-source and free to use. Testkube Community License (TCL): Covers additional enterprise functionalities. Key Features Test Workflows (Primary Custom Resource Definition - CRD) Replaces the older CRDs (Test, TestSuite, and Executor). Manages the full lifecycle of tests in Kubernetes. Supports multiple testing tool versions and dependencies. Allows defining multiple execution steps with setup/teardown processes. Configures tool-specific commands and arguments. Provides better resource management and test control. Kubernetes-Native Execution Analyzes expected operations and images to build required Kubernetes resources (ConfigMaps, Secrets, Jobs, and Pods). Automatically deletes created resources after test execution. Components: Job: Schedules test execution. Pod: Executes requested operations and returns logs. Enterprise Features Exclusive for Testkube Enterprise users. Enhanced orchestration and management capabilities. Centralized Reporting and Analysis Provides a dashboard to manage test executions, logs, and artifacts. Supports advanced analytics for informed decision-making. Testkube Test Workflow Test Workflows are the primary Custom Resource Definition (CRD) in Testkube, replacing the older CRDs (Test, TestSuite, and Executor). They manage the full lifecycle of tests in Kubernetes, offering several key features:\nRunning Tests: Supports different testing tool versions and dependencies. Multiple Execution Steps: Allows defining multiple steps for test execution, including setup and teardown processes. Enhanced Control: Provides more control over test execution, including resource consumption and setup/teardown processes. Tool-Specific Commands: Enables configuration of tool-specific commands and arguments. Test Workflows analyze the expected operations and images, and build all the required native Kubernetes resources, such as ConfigMaps and Secrets for data, and most importantly, Jobs and Pods for the actual execution. After the Test Workflow execution is finished, all the created resources are deleted from the Kubernetes cluster.\nComponents: Job: For every execution, a Job is created to schedule the actual execution pod. Pod: Based on the Test Workflow, a Pod is built to execute all the requested operations and return all the information within its logs. Example of a Test Workflow for running Postman tests: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 kind: TestWorkflow apiVersion: testworkflows.testkube.io/v1 metadata: name: postman-sample namespace: testkube labels: docs: example content: git: uri: https://github.com/kubeshop/testkube revision: main paths: - test/postman/executor-tests/postman-executor-smoke-without-envs-postman_collection.json container: workingDir: /data/repo/test/postman/executor-tests resources: requests: cpu: 256m memory: 128Mi steps: - name: Run test run: image: postman/newman:6-alpine args: - run - postman-executor-smoke-without-envs.postman_collection.json Testkube Architecture Testkube consists of two main components:\nTestkube Agent running in cluster that manages Testkube resources, runs tests, gathers results, etc. Helm Chart: helm-charts Testkube Server (Control plane) includes the Testkube Dashboard, Storage for Results/Artifacts, Cluster Federation, etc Helm Chart: testkube-cloud-charts Additional components are: Dex: identity provider MinIO: storage backend for storing artifacts NATS: message broker for communication between API and Agents MongoDB: database for storing all the data (logs, test results â€¦) PS: The testkube agent and testkube server can be deployed in different clusters Triggering Tests in Testkube Test workflows can be triggered through multiple mechanisms:\nManual Execution Tests can be triggered directly from the Testkube Dashboard. Kubernetes Event-Based Triggers Automates Test Workflows based on Kubernetes resource events (e.g., Deployment updates, Ingress deletions). Uses selectors (nameRegex, labelSelector) and conditions (e.g., Progressing, Available) to define triggers. CLI Execution Commands to trigger tests: Free version: testkube set context --kubeconfig Pro version: testkube set context --org-id $TESTKUBE_ORG_ID --env-id $TESTKUBE_ENV_ID -c cloud --root-domain test.bare.pandrosion.org --api-prefix testkube-api -k $TESTKUBE_API_TOKEN Running a test: testkube run \u0026lt;resource_type\u0026gt; \u0026lt;resource_name\u0026gt; API Execution Tests can be triggered using a POST request to the Testkube Agent API:\n1 POST https://testkube- api.test.bare.pandrosion.org/organizations/$TESTKUBE_ORG_ID/environments/$TESTKUBE_ENV_ID/agent/test- workflows/$TEST/executions ```\nAuthorization: Bearer Token (generated in Testkube Dashboard). Required variables stored in Vault under: testkube-cloud. Use Cases Load and Performance Testing Supports tools like K6, JMeter, and Gatling for distributed load testing. End-to-End (E2E) Testing Run E2E tests using frameworks like Playwright, Cypress, and Selenium. API Testing Integrate with Postman, SoapUI, and REST Assured for API testing workflows. Hardware Testing Test hardware components like GPUs in Kubernetes clusters using Testkube\u0026rsquo;s TestWorkflows. Python Testing with Pytest Simplifies the integration of Pytest into Kubernetes, enabling scalable and efficient testing workflows. Conclusion Testkube is a game-changer for cloud-native testing, offering a scalable, flexible, and vendor-agnostic platform for running tests in Kubernetes environments. Whether you\u0026rsquo;re a developer, tester, or DevOps engineer, Testkube empowers you to deliver high-quality software with confidence. For more information, visit the Testkube Documentation or explore the Testkube Blog for the latest updates and tutorials.\n","date":"2025-02-07T16:27:00+02:00","image":"cherifsahraoui.github.io/cherifsahraoui.github.io/cherifsahraoui.github.io/p/testkube/testkube_logo_hu_8a50e27b1f304876.jpg","permalink":"cherifsahraoui.github.io/p/testkube/","title":"Testkube: Kubernetes-Native Test Orchestration and Execution Platform"}]